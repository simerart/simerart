<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D STL Model with GIF</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #711e72, #2a5298);
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      display: block;
      cursor: pointer;
    }
p {
  text-align:justify;
  font-family: Lato;
      font-size: 12px;
      letter-spacing: 1px;
      margin-top: 3px;
      margin-bottom: -12px;
}
    #gifContainer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      display: none;
    }

    #gifImage {
      max-width: 80vw;
      max-height: 80vh;
      border-radius: 10px;
      display: block;
    }

    #closeButton {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #ff4757;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }

    #closeButton:hover {
      background: #ff3838;
      transform: scale(1.1);
    }

    #instructions {
      position: absolute;
      bottom: 88px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      text-align: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 15px 25px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      animation: pulse 2s infinite;
      width: 62%;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    
    <div id="gifContainer">
      <button id="closeButton">&times;</button>
      <!-- ðŸ‘‡ Replace with your GIF file -->
      <img id="gifImage" src="imfine copy.gif" alt="GIF Animation">
    </div>
    <br>
    
    <div id="instructions">
      <p>This Super 8 film uses deliberate scratching techniques to retrieve and translate my personal experience with seizures and medical treatment into visual form. Each mark on the emulsion mirrors the neurological disruption that fragments of consciousness.</p>
      <br><br>
      <strong>Click on the 3D model to view the Video</strong>
    </div>
    
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- STL Loader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

  <script>
    let scene, camera, renderer, model, raycaster, mouse;
    let rotationDirection = 1;
    let rotationSpeed = 0.008;
    let maxRotation = Math.PI / 3;
    let isPaused = false;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Load STL model or create fallback
      const loader = new THREE.STLLoader();
      loader.load("base.stl", (geometry) => {
        const material = new THREE.MeshPhongMaterial({ 
          color: 0x0077ff, 
          shininess: 100 
        });
        model = new THREE.Mesh(geometry, material);
        model.scale.set(1.50, 1.50, 1.50);
        model.rotation.x = -Math.PI / 90;
        scene.add(model);
      }, undefined, (error) => {
        console.warn('Could not load STL file, creating fallback:', error);
        createFallbackModel();
      });

      camera.position.z = 5;

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      setupEventListeners();
      animate();
    }

    function createFallbackModel() {
      // Create a simple 3D button as fallback
      const geometry = new THREE.CylinderGeometry(1.2, 1.4, 0.3, 32);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x0077ff, 
        shininess: 100 
      });
      model = new THREE.Mesh(geometry, material);
      scene.add(model);
    }

    function setupEventListeners() {
      // Simple click event - no dragging
      renderer.domElement.addEventListener("click", onMouseClick);
      document.getElementById("closeButton").addEventListener("click", closeGIF);
      window.addEventListener("resize", onWindowResize);
      document.addEventListener("keydown", (e) => { 
        if (e.key === "Escape") closeGIF(); 
      });
    }

    function onMouseClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (model) {
        const intersects = raycaster.intersectObject(model, true);
        if (intersects.length > 0) {
          openGIF();
        }
      }
    }

    function openGIF() {
      // Don't pause the rotation - let it continue
      document.getElementById("gifContainer").style.display = "block";
    }

    function closeGIF() {
      // Keep the rotation going even after closing
      document.getElementById("gifContainer").style.display = "none";
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Slow left-to-right pan rotation (only when not paused)
      if (model && !isPaused) {
        model.rotation.y += rotationSpeed * rotationDirection;
        
        // Reverse direction when reaching limits
        if (model.rotation.y > maxRotation) {
          rotationDirection = -1;
        } else if (model.rotation.y < -maxRotation) {
          rotationDirection = 1;
        }
      }
      
      renderer.render(scene, camera);
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>